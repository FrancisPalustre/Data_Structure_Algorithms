#include <iostream>
#include <vector>

//A_Star Libraries
#include <queue>
#include <algorithm>
#include <unordered_map>

using namespace std;

struct cost {
    int gn =0; //cost from start node to current node
    int hn =0; //heuristic cost from current node to goal node
    int fn =0; //total cost
};

//Function to calculate Manhattan distance
void manhatten (int currNode, int desiredNode, int cols, cost &cost) {

    //calculating the XY-coordinate of current node to goal node
    int currNodeX = (currNode - 1) / cols;
    int currNodeY = (currNode - 1) % cols;;

    //calculating the XY-coordinate of desired node to goal node
    int desiredNodeX = (desiredNode - 1) / cols;;
    int desiredNodeY = (desiredNode - 1) % cols;

    //calculating the Manhattan distance
    cost.hn = abs(currNodeX - desiredNodeX) + abs(currNodeY - desiredNodeY);
    cost.fn = cost.gn + cost.hn; //updating the total cost
}

//A* algorithm implementation
unordered_map<int, int> A_Star(unordered_map<int, unordered_map<int, cost>> &graph, int startNode, int desiredNode) {
    //containers for A* algorithm
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq; //priotiy queue to store the nodes
    unordered_map<int, int> path; //stores the shortest path
    unordered_map<int, int> distance; //stores the distance from one node to the next

    for (auto &node: graph) {//setting the distance of each node to inf 
        distance[node.first] = numeric_limits<int>::max();
    } distance[startNode] = 0; //setting the distance of the start node to 0

    //storing the first node in the priority queue with startNode w/ distance of 0
    pq.push(make_pair(0, startNode));

    while (!pq.empty()) {
        //get the node with the lowest total cost from the priority queue
        pair<int, int> getNode = pq.top();
        
        //remove curre=nt node from priority queue
        pq.pop();

        //get the node and the total cost from the pair
        int currNode = getNode.second;

        //if the current node is the desired node, return the path
        if (currNode == desiredNode) {
            return path; 
        }

        //iteratoes all neighbors of current node
        for (auto& adjNodes: graph[currNode]) {
            int distance_final = distance[currNode] + adjNodes.second.gn;//distance calculations

            //checking if the new distance is less than the current distance
            if (distance_final < distance[adjNodes.first]) {

                //updating the path and distance for the adjacent node
                path[adjNodes.first] = currNode;
                distance[adjNodes.first] = distance_final;

                //updating the cost of adjacent node
                adjNodes.second.fn = distance_final + adjNodes.second.hn;
                
                //adding the adjacent node to the priority queue
                pq.push(make_pair(adjNodes.second.fn, adjNodes.first));

            }
        }

    }
    return unordered_map<int, int> {};
}

//Path Generation
void path(unordered_map<int, unordered_map<int, cost>> graph, int startNode, int desiredNode) {
    //map is set to the final path generated by A*, but it is in reverse order
	unordered_map<int, int> roboPath =  A_Star(graph, startNode, desiredNode);

    vector <int> mainPath; //houses the proper path

    //reverses roboPath and store the correcte path in mainPath
    for (int it = desiredNode; it != startNode; it = roboPath[it]) {
        mainPath.insert(mainPath.begin(), it);
    }
    mainPath.insert(mainPath.begin(), startNode);

	//couts the generated path
    cout << "\nPath: ";
	for (const auto &node : mainPath) {
    	cout << node << " "; 
	} cout << endl;
}

//Edge Reomval Function
unordered_map<int, unordered_map<int, cost>> removeEdges(unordered_map<int, unordered_map<int, cost>> graph, vector<int>& removeVec) {
    //iterating through each node in the removeVec vector
    for (int node : removeVec) {
        
        //iterating through each of the edges of the current node
        for (const auto& edges : graph[node]) {
            int adjNode = edges.first; //getting the adjacent node of edges
            
            //removing the edges between adjacent and current node
            graph[adjNode].erase(node);
        }
        graph[node].clear(); //removing current node from graph
    }
    return graph;
}

//Graph Creation
unordered_map<int, unordered_map<int, cost>> graphFunction(int rows, int cols) {
    int total = rows * cols; //total size/nodes of graph
    
    unordered_map<int, unordered_map<int, cost>> graph;

    //iterating through each node in the graph
    for (int i = 1; i <= total; i++) {
        unordered_map<int, cost> adjNodes;
        //connecting the node to its left neighbor, if it's not on the leftmost column
        if (i % cols != 1) {
            adjNodes[i - 1].gn = 3; //adding left neighbor with a cost of 3
        }

        //connecting the node to its right neighbor, if it's not on the rightmost column
        if (i % cols != 0) {
            adjNodes[i + 1].gn = 3; //adding right neighbor with a cost of 3
        }
        
        //connecting the node to its upper neighbor, if it's not in the topmost row
        if (i - cols > 0) {
            adjNodes[i - cols].gn = 3; //adding upper neighbor with a cost of 3
        }
        
        //connecting the node to its lower neighbor, if it's not in the bottommost row
        if (i + cols <= total) {
            adjNodes[i + cols].gn = 3; //adding lower neighbor with a cost of 3
        }

        graph[i] = adjNodes; //assgining the adjacent nodes to the current node
    }

    return graph;
}

int main() {
    //setting parameters for graph
    int rows = 6;
    int cols = 6;

    //creating graph
    unordered_map<int, unordered_map<int, cost>> graph = graphFunction(rows, cols);;

	//setting parameters for path traversal
    int startingNode = 0;
    int desiredNode = 0;
    int nodeRemoval =0;
        
    //inputs of desired start and end nodes with desired removal
    cout << "Starting Node: ";
    cin >> startingNode;
        
    cout << "Desired Node: ";
    cin >> desiredNode;

    cout << "\nHow many nodes to remove: ";
    cin >> nodeRemoval;
    
	//vector that houses the nodes/edges you want to remove from graph
    vector <int> removeVec;
    int input = 0;
        
    cout << "\nList:" <<endl;
    for (int i =0; i < nodeRemoval; i++) {
        cout << "Node " << i+1 << ": ";
        cin >> input;
        removeVec.push_back(input);    
    }

	//Resultant graph after removing edges
	graph = removeEdges(graph, removeVec);

    for (auto &node : graph) {
        for (auto &adjNodes : node.second) {
            manhatten(adjNodes.first, desiredNode, cols, adjNodes.second);
        } 
    }

	path(graph, startingNode, desiredNode);

    return 0;
}